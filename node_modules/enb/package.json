{
  "author": {
    "name": "Marat Dulin",
    "email": "mdevils@yandex.ru"
  },
  "description": "Faster BEM/BEViS assembler",
  "name": "enb",
  "version": "0.13.17",
  "repository": {
    "type": "git",
    "url": "https://github.com/enb-make/enb"
  },
  "contributors": [
    {
      "name": "Marat Dulin",
      "email": "mdevils@yandex.ru"
    },
    {
      "name": "BEM Tools",
      "url": "http://bem.info"
    }
  ],
  "engines": {
    "node": ">= 0.10.0"
  },
  "dependencies": {
    "borschik": "1.0.0",
    "commander": "1.1.1",
    "connect": "3.1.1",
    "dom-js": "0.0.9",
    "inherit": "~2.1.0",
    "js-yaml": "2.1.0",
    "mad": ">=0.4.0",
    "madify": ">=0.0.1",
    "mime": "1.2.11",
    "puml-link": "0.0.1",
    "send": "0.8.3",
    "serve-static": "1.5.3",
    "sibling": ">=0.0.3",
    "stylus": "0.40.x",
    "vow": "~0.3.9",
    "vow-fs": "~0.2.2"
  },
  "devDependencies": {
    "bh": "0.1.14",
    "chai": "1.7.2",
    "coveralls": "~2.11.2",
    "enb-validate-code": "0.0.1",
    "istanbul": "0.2.10",
    "jscs": "~1.2.3",
    "jshint": "2.1.3",
    "mocha": "2.0.1",
    "sinon": "1.7.3",
    "unit-coverage": "~3.2.0"
  },
  "bin": {
    "enb": "./bin/enb"
  },
  "unit-coverage": {
    "common": [
      "-s",
      "lib/**/*.js",
      "-e",
      "node_modules/**",
      "-t",
      "test/**",
      "-a",
      "lib",
      "-a",
      "techs",
      "-S",
      "relative",
      "-O",
      "tests=test",
      "--",
      "-u",
      "bdd",
      "-R",
      "spec",
      "--recursive",
      "techs",
      "lib",
      "test/lib",
      "test/techs"
    ]
  },
  "scripts": {
    "test": "npm run-script jshint && npm run-script check-style && npm run-script func-test",
    "jshint": "jshint .",
    "unit-test": "mocha -u bdd -R spec --recursive test/lib test/techs",
    "func-test": "npm run-script bh-sym && npm run-script build-sample-proj && mocha -u bdd -R spec --recursive test/func",
    "bh-sym": "mkdir -p node_modules/bh/node_modules && rm -f node_modules/bh/node_modules/enb && ln -s ../../.. node_modules/bh/node_modules/enb",
    "build-sample-proj": "./bin/enb make -n --graph --dir test/fixtures/sample-project",
    "check-style": "jscs -c node_modules/enb-validate-code/jscs.json lib exlib techs test",
    "coverage": "unit-coverage run -p common",
    "coverage-html": "unit-coverage run -p common -r html -o coverage.html",
    "travis": "npm run test && unit-coverage run -p common -r lcov -o report.lcov && cat report.lcov | coveralls"
  },
  "readme": "ENB [![Build Status](https://travis-ci.org/enb-make/enb.svg?branch=master)](https://travis-ci.org/enb-make/enb) [![Coverage Status](https://img.shields.io/coveralls/enb-make/enb.svg?branch=master)](https://coveralls.io/r/enb-make/enb)\n===\n\nСборщик проектов. С помощью ENB можно собрать любой проект, который строится на модели node / target.\n\n**ВАЖНО:** Конфигуратор для упрощения создания конфига: [http://enb-make.info/config/](http://enb-make.info/config/).\n\n**Возможности**\n\n* Сборка проекта и конкретных таргетов в разных режимах (с помощью ENV-переменной `YENV`).\n* Режим сервера как в виде самостоятельного express-сервера, так и в виде express-middleware.\n\n**Зачем нужен этот проект, если есть bem-tools?**\n\nENB работает гораздо быстрее, чем bem-tools. Причем, как в режиме сборки, так и в режиме сервера.\n\n**Почему?**\n\n* Гибкая система кэширования.\n* Обмен промежуточными данными в процессе сборки.\n* Разбиение технологий на более мелкие (избавляемся от повторной работы).\n* Используются более быстрые библиотеки (например, https://github.com/dfilatov/jspromise вместо Q).\n* Нет порядка выполнения технологий (технологии зависят от таргетов, а не друг от друга), технологии зачастую выполняются параллельно.\n* Тяжелые синхронные технологии выделяются в субпроцессы.\n\n**Некоторые отличия от bem-tools**\n\n* ENB (как платформа) свободна от идеологии BEM. Сбор префиксов не является частью платформы, а реализуется с помощью одной из технологий.\n* Технологии в ENB не ограничены в том, каким образом они будут собирать те или иные таргеты.\n* Все технологии настраиваемые (в большей или меньшей степени).\n* ENB сложнее настроить для проекта. В нем нет готовых шаблонов make-файлов.\n* В рамках ENB одна и та же технология может быть использована с разными опциями. Например, можно построить несколько разных `deps.js` в рамках одной ноды на основе различных `bemdecl.js`.\n\n**Как потестить?**\n\nСпециально для этого я подготовил сборку project-stub на ENB: https://github.com/mdevils/project-stub\n\n**Пакеты для ENB**\n\n* Сборка BEMHTML: https://github.com/enb-make/enb-bemhtml\n* Модульность для нового bem-core: https://github.com/enb-make/enb-modules\n* Интеграция для grunt: https://github.com/megatolya/grunt-enb\n\nБлагодарности\n-------------\n\n* Дмитрию Филатову (@dfilatov). За `vow`, `vow-fs`, `inherit`, советы, поддержку и мотивацию.\n* Дмитрию Ковалю (@smith). За помощь в сборке тестов, production-режима и здоровый скептицизм.\n* Александру Тармолову (@hevil). За помощь с `git`, `modules`, поддержку и полезные ссылки.\n* Вениамину Клещенкову (@benjamin). За помощь в отладке и доработке ENB, поддержку, советы и ревью.\n* Сергею Бережному (@veged). За `borschik`, советы и правильные вопросы.\n* Команде разработчиков bem-tools. За часть заимствованного кода.\n* Егору Блинову (@escaton). За пулл-реквесты, идеи.\n* Андрею Абрамову (@andrewblond). За пулл-реквесты.\n\nИспользование из командной строки\n---------------------------------\n\nПредполагается, что вы установили `npm`-пакет `enb` и находитесь в корне проекта.\n\nСборка всех страниц проекта:\n```\n./node_modules/.bin/enb make\n```\n\nСборка всех страниц проекта со сбросом кэша:\n```\n./node_modules/.bin/enb make --no-cache\n```\n\nСборка всех страниц проекта с построением графа сборки:\n```\n./node_modules/.bin/enb make --graph\n```\n\nСборка конкретной страницы проекта:\n```\n./node_modules/.bin/enb make pages/index\n```\n\nСборка конкретного файла:\n```\n./node_modules/.bin/enb make pages/index/index.html\n```\n\nЗапуск в режиме сервера:\n```\n./node_modules/.bin/enb server\n```\n\nОтключение цветового форматирования при выводе прогресса в консоль:\n```\nNOCOLOR=1 ./node_modules/.bin/enb make\n```\n\nУстановка лимита открытых файлов для асинхронных операций. Правильно выбранный лимит позволяет избежать `EMFILE`-ошибок:\n```\nENB_FILE_LIMIT=100 ./node_modules/.bin/enb make\n```\n\nТерминология\n------------\n\n* Target (таргет) — это цель для сборки. Например, таргетом может быть `index.js` в рамках ноды `pages/index`..\n* Node (нода) — это папка, в которой находятся те или иные таргеты. Например, `pages/index`.\n* Suffix (суффикс) — это расширение исходного или конечного файла. Например, `js`.\n* Masked Target (замаскированный таргет) — это имя таргета, которое может содержать `?`. Знак `?` заменяется на имя ноды в процессе настройки технологии, а с помощью подстроки `{lang}` можно создать несколько копий технологии для каждого из языков, где `{lang}` заменится на аббревиатуру языка в каждой из копий технологии. Например, таргет `?.js` заменяется на `search.js`, если нода — `pages/search`. Такой подход удобен, когда мы настраиваем несколько нод через `nodeMask`.\n* Make-файл — файл, в котором конфигурируется ENB для сборки проекта. Находится в папке `<project_root>/.enb/make.js`.\n* Билдить — собирать, компилировать (используется в отношении таргетов).\n\nПроцесс сборки\n--------------\n\n1. Какие таргеты необходимо билдить `ENB` узнаёт из команды `enb make [target]`. Если вы запустили `enb make` без указания конкретного таргета, `ENB` будет собирать все таргеты, определенные в `make.js`.\n2. `ENB` инициализирует ноды, участвующие в сборке указанных таргетов. В это время каждая нода спрашивает у технологий (которые регистрировались внутри ноды) список таргетов.\n3. Запускаются технологии, которые отвечают за те таргеты, которые необходимо билдить.\n4. В процессе выполнения технология может потребовать у ноды другие таргеты, необходимые для сборки (с помощью метода `requireSources`). В таком случае технология приостанавливается, нода запускает технологии, отвечающие за требуемые таргеты (если они не запущены) и после того, как технологии заканчивают сборку нужных таргетов, продолжает свою работу искомая технология.\n5. После того, как технология выполнила свою работу по сборке таргета, она оповещает об этом ноду (с помощью метода `resolveTarget`).\n6. Сборка завершается после того, как все необходимые таргеты собраны.\n\nКак собрать проект - пошаговое руководство\n==========================================\n\n1. Прописать в `package.json` проекта зависимость от пакета `enb` (желательно в виде \">=последняя_версия\").\n2. Выполнить `npm install`.\n3. Проверить, что `ENB` установлен. Команда `node_modules/.bin/enb` должна выполниться без ошибок.\n4.\n  Создать make-файл `.bem/enb-make.js` вида:\n\n  ```javascript\n  module.exports = function(config) {\n  };\n  ```\n5. Проверить, что `ENB` работает. Команда `node_modules/.bin/enb make` должна выполниться без ошибок.\n6.\n  Теперь нужно настроить ноды. Для примера, я приведу вариант настройки ноды `pages/index`.\n\n  ```javascript\n  module.exports = function(config) {\n      config.node('pages/index', function(nodeConfig) {\n      });\n  };\n  ```\n  Так объявляется нода в рамках make-платформы. В данный момент она не настроена, а лишь объявлена.\n7.\n  Объявим таргеты, которые надо собрать для ноды:\n\n  ```javascript\n  module.exports = function(config) {\n      config.node('pages/index', function(nodeConfig) {\n        nodeConfig.addTargets(['_?.js', '_?.css']);\n      });\n  };\n  ```\n  Таргеты объявлены, но при попытке выполнить `node_modules/.bin/enb make` будет ошибка, т.к. не зарегистрированы технологии, которые могут предоставить таргеты.\n8.\n  Зарегистрируем базовые технологии:\n  ```javascript\n  module.exports = function(config) {\n      config.node('pages/index', function(nodeConfig) {\n        nodeConfig.addTechs([\n          [ require('enb/techs/levels'), { levels: getLevels(config) } ],\n          [ require('enb/techs/file-provider'), { target: '?.bemdecl.js' } ],\n          require('enb/techs/deps-old'),\n          require('enb/techs/files')\n        ]);\n\n        nodeConfig.addTargets(['_?.js', '_?.css']);\n      });\n  };\n\n  function getLevels(config) {\n      return [\n        {path: 'bem-bl/blocks-common', check: false},\n        {path: 'bem-bl/blocks-desktop', check: false},\n        {path: 'lego/blocks-common', check: false},\n        {path: 'lego/blocks-desktop', check: false},\n        'common.blocks',\n        'desktop.blocks'\n      ].map(function(levelPath) { return config.resolvePath(levelPath); });\n  }\n  ```\n  Чтобы не засорять конфиг ноды, функцию `getLevels` мы выносим в нижнюю часть файла.\n\n  Рассмотрим каждую технологию:\n\n  **enb/techs/levels** — собирает информацию об уровнях переопределения проекта. Результат выполнения этой технологии необходим технологиям `enb/techs/deps`, `enb/techs/deps-old` и `enb/techs/files`. Для каждой ноды по умолчанию добавляется уровень `<путь_к_ноде>/blocks`. Например, для ноды `pages/index` — `pages/index/blocks`.\n\n  **enb/techs/file-provider** — сообщает make-платформе, что таргет (переданный в опции `target`) уже готов. В нашем случае, исходным файлом для сборки является `index.bemdecl.js`. Он лежит в репозитории и отдельная сборка для него не требуется.\n\n  **enb/techs/deps-old** — собирает `?.deps.js` (`index.deps.js`) на основе `index.bemdecl.js` и `index.levels`. Почему `deps-old`? В lego не хватает ряда зависимостей, поэтому ваш проект может не собраться с более быстрый технологией `deps` без модификации lego. Технология `deps-old` повторяет алгоритм сборки из `bem-tools` и нехватка зависимостей становится незаметной, как раньше.\n\n  **enb/techs/files** — собирает полный список файлов со всех уровней переопределения в том порядке, в котором они идут в финальном `index.deps.js`. Результат этой технологии может использоваться, например, в технологии `enb/techs/js`.\n\n9.\n  Регистрируем технологии, необходимые для сборки js и css.\n  ```javascript\n  module.exports = function(config) {\n      config.node('pages/index', function(nodeConfig) {\n        nodeConfig.addTechs([\n          [ require('enb/techs/levels'), { levels: getLevels(config) } ],\n          [ require('enb/techs/file-provider'), { target: '?.bemdecl.js' } ],\n          require('enb/techs/deps-old'),\n          require('enb/techs/files'),\n          require('enb/techs/js'),\n          require('enb/techs/css')\n        ]);\n\n        nodeConfig.addTargets(['_?.js', '_?.css']);\n      });\n  };\n\n  function getLevels(config) {\n      return [\n        {path: 'bem-bl/blocks-common', check: false},\n        {path: 'bem-bl/blocks-desktop', check: false},\n        {path: 'lego/blocks-common', check: false},\n        {path: 'lego/blocks-desktop', check: false},\n        'common.blocks',\n        'desktop.blocks'\n      ].map(function(levelPath) { return config.resolvePath(levelPath); });\n  }\n  ```\n  Теперь файлы `index.js` и `index.css` могут собираться с помощью технологий `enb/techs/js` и `enb/techs/css` соответственно.\n  Но мы регистрировали иные таргеты: `_?.js` (`_index.js`) и `_?.css` (`_index.css`). Для их сборки воспользуемся технологией `enb/techs/file-copy`.\n  ```javascript\n  module.exports = function(config) {\n      config.node('pages/index', function(nodeConfig) {\n        nodeConfig.addTechs([\n          [ require('enb/techs/levels'), { levels: getLevels(config) } ],\n          [ require('enb/techs/file-provider'), { target: '?.bemdecl.js' } ],\n          require('enb/techs/deps-old'),\n          require('enb/techs/files'),\n          require('enb/techs/js'),\n          require('enb/techs/css'),\n          [ require('enb/techs/file-copy'), { sourceTarget: '?.js', destTarget: '_?.js' } ],\n          [ require('enb/techs/file-copy'), { sourceTarget: '?.css', destTarget: '_?.css' } ]\n        ]);\n\n        nodeConfig.addTargets(['_?.js', '_?.css']);\n      });\n  };\n\n  function getLevels(config) {\n      return [\n        {path: 'bem-bl/blocks-common', check: false},\n        {path: 'bem-bl/blocks-desktop', check: false},\n        {path: 'lego/blocks-common', check: false},\n        {path: 'lego/blocks-desktop', check: false},\n        'common.blocks',\n        'desktop.blocks'\n      ].map(function(levelPath) { return config.resolvePath(levelPath); });\n  }\n  ```\n  Теперь можно выполнить команду `node_modules/.bin/enb make` и в папке `pages/index` будут столь нужные нам `_index.js` и `_index.css`.\n  Окей, мы получили результат, с которым можно работать. Но как же production-режим?\n\n10.\n  Разделяем сборку финальных файлов для разных режимов.\n  ```javascript\n  module.exports = function(config) {\n      config.node('pages/index', function(nodeConfig) {\n        nodeConfig.addTechs([\n          [ require('enb/techs/levels'), { levels: getLevels(config) } ],\n          [ require('enb/techs/file-provider'), { target: '?.bemdecl.js' } ],\n          require('enb/techs/deps-old'),\n          require('enb/techs/files'),\n          require('enb/techs/js'),\n          require('enb/techs/css')\n        ]);\n\n        nodeConfig.mode('development', function(nodeConfig) {\n          nodeConfig.addTechs([\n            [ require('enb/techs/file-copy'), { sourceTarget: '?.js', destTarget: '_?.js' } ],\n            [ require('enb/techs/file-copy'), { sourceTarget: '?.css', destTarget: '_?.css' } ]\n          ]);\n        });\n\n        nodeConfig.mode('production', function(nodeConfig) {\n          nodeConfig.addTechs([\n            [ require('enb/techs/borschik'), { sourceTarget: '?.js', destTarget: '_?.js', minify: true } ],\n            [ require('enb/techs/borschik'), { sourceTarget: '?.css', destTarget: '_?.css', minify: true } ]\n          ]);\n        });\n\n        nodeConfig.addTargets(['_?.js', '_?.css']);\n      });\n  };\n\n  function getLevels(config) {\n      return [\n        {path: 'bem-bl/blocks-common', check: false},\n        {path: 'bem-bl/blocks-desktop', check: false},\n        {path: 'lego/blocks-common', check: false},\n        {path: 'lego/blocks-desktop', check: false},\n        'common.blocks',\n        'desktop.blocks'\n      ].map(function(levelPath) { return config.resolvePath(levelPath); });\n  }\n  ```\n  Теперь для production-режима конечные файлы обрабатываются [Борщиком](https://github.com/bem/borschik). Production-режим запускается командой `YENV=production node_modules/.bin/enb make`\n\n11. Сборка `js` и `css` работает. Если в вашем проекте присутствуют другие цели или мультиязычность, то можно продолжить чтение данной документации в поисках информации о небходимых технологиях.\n12. Собираем `node_modules/.bin/enb make`.\n\nНастройка сборки\n================\n\n```javascript\nmodule.exports = function(config) {\n\n  // Языки для проекта.\n  config.setLanguages(['ru', 'en']);\n\n  // Добавление набора нод в сборку.\n  config.nodes('pages/*');\n\n  // Добавление ноды в сборку + конфигурирование ноды.\n  config.node('pages/index', function(nodeConfig) {\n    // Переопределение языков для конкретной ноды.\n    nodeConfig.setLanguages(['ru']);\n\n    // Добавление одной технологии с опциями.\n    nodeConfig.addTech([ require('enb/techs/file-provider'), { target: '?.bemdecl.js' } ]);\n\n    // Добавление нескольких технологий.\n    nodeConfig.addTechs([\n      [ require('enb/techs/levels'), {\n        levels: [\n          'common.blocks',\n          'desktop.blocks'\n        ].map(function(config) { return config.resolvePath(level); }) // Резолвинг путей от корня проекта.\n      }],\n      require('enb/techs/deps'),\n      require('enb/techs/files'),\n\n      // Добавление технологии с опциями\n      [ require('enb/techs/js'), { target: '?.new.js' } ],\n      require('enb/techs/css')\n    ]);\n\n    // Добавление одного таргета.\n    nodeConfig.addTarget('?.css');\n\n    // Добавление нескольких таргетов.\n    nodeConfig.addTargets(['?.css', '?.js']);\n  });\n\n  // Настройки для режима development.\n  config.mode('development', function() {\n    // Настройка нод по маске (regex).\n    config.nodeMask(/pages\\/.*/, function(nodeConfig) {\n      nodeConfig.addTechs([\n        [ require('enb/techs/file-copy'), { sourceTarget: '?.css', destTarget: '_?.css'} ],\n        [ require('enb/techs/file-copy'), { sourceTarget: '?.js', destTarget: '_?.js'} ]\n      ]);\n    });\n  });\n\n  // Настройки для режима production.\n  config.mode('production', function() {\n    // Настройка нод по маске (regex).\n    config.nodeMask(/pages\\/.*/, function(nodeConfig) {\n      nodeConfig.addTechs([\n        [ require('enb/techs/borschik'), { sourceTarget: '?.css', destTarget: '_?.css'} ],\n        [ require('enb/techs/borschik'), { sourceTarget: '?.js', destTarget: '_?.js'} ]\n      ]);\n    });\n  });\n\n  // Регистрация таска.\n  config.task('i18n.get', function(task) {\n    // Выполнение shell-команды.\n    return task.shell('./blocks/lego/tools/get-tanker.js');\n  });\n\n  // Установка переменных среды для shell-команд.\n  config.setEnv({\n      PRJ_ROOT        : config.resolvePath(), // Получение абсолютного пути к папке с проектом.\n      TANKER_HOST     : 'tanker-test.yandex-team.ru',\n      TANKER_PRJ      : 'super-project',\n      TANKER_PRJ_REV  : 'master'\n  });\n};\n```\n\nАвтоматизация с помощью express\n===============================\n\nПри разработке `nodejs`-приложений на базе `express` можно сильно упростить использование `enb` в `development`-режиме.\n\nСуть в том, что можно забыть о пересборке проекта, о других портах для статики и т.п. Можно просто отправлять в `ENB`\nзапросы на сборку тогда, когда это необходимо. То есть, когда вы открываете в браузере свой проект.\n\nДля этого можно воспользоваться `express`-совместимым `middleware`. Его возвращает метод `createMiddleware` модуля\n`lib/server/server-middleware`.\n\n```javascript\n/**\n * @param {Object} options\n * @param {String} options.cdir Корневая директория проекта.\n * @param {Boolean} options.noLog Не логгировать в консоль процесс сборки.\n * @returns {Function}\n */\nmodule.exports.createMiddleware = function(options) { /* ... */ };\n```\n\nПример использования:\n\n```javascript\napp\n    .use(require('enb/lib/server/server-middleware').createMiddleware())\n    .get('/', function (req, res) {\n        /* ... */\n    });\n```\n\nСборка по требованию\n====================\n\nПомимо упрощения сборки статики в `dev`-режиме с помощью `ENB` в `express`-приложениях,\nможно собирать по требованию различные ресурсы, например, шаблоны.\n\nЕсли `nodejs` приложению в процессе работы требуется собирать шаблоны или локализацию (или что-нибудь еще),\nто можно воспользоваться методом `createBuilder` модуля `lib/server/server-middleware`.\n\n```javascript\n/**\n * @param {Object} options\n * @param {String} options.cdir Корневая директория проекта.\n * @param {Boolean} options.noLog Не логгировать в консоль процесс сборки.\n * @returns {Function}\n */\nmodule.exports.createBuilder = function(options) { /* ... */ };\n```\n\nПример использования:\n\n```javascript\nvar enbBuilder = require('enb/lib/server/server-middleware').createBuilder();\nvar dropRequireCache = require('enb/lib/fs/drop-require-cache');\napp\n    .get('/', function (req, res, next) {\n        var bemhtmlFilePath = 'pages/index/index.bemhtml.js';\n        enbBuilder(bemhtmlFilePath).then(function() {\n            var bemhtmlAbsFilePath = process.process.cwd() + '/' + bemhtmlFilePath;\n            dropRequireCache(require, bemhtmlAbsFilePath);\n            var bemhtml = require(bemhtmlAbsFilePath);\n            res.end(bemhtml.BEMHTML.apply({block: 'b-page', content: 'Hello World'}));\n            next();\n        }, next);\n    });\n```\n\nСборка merged (common) бандла\n-----------------------------\n\n>  Merged бандл — это бандл, который объединяет в себе декларации всех бандлов уровня. Соответственно по такой объединенной декларации собираются и объединенные конечные файлы. Например, css будет включать в себе все стили, используемые всеми бандлами.\n>\n>  Merged бандл может быть полезен, например, если вы хотите использовать общие файлы статики (js, css) для нескольких страниц проекта.\n>  (c) bem.info\n\nОдним из решений может быть:\n\n1. Проход по всем нодам и копирование deps в общую (`common`) папку (см. `deps-provider`);\n\n2. Мердж всех депсов в один (см. `deps-merge`).\n\nРазберем на примере:\n\nПредположим, есть 3 ноды:\n\n* `pages/index`\n* `pages/search`\n* `pages/order`\n\nУ каждой страницы свои уникальными стили и скрипты. Нам нужно собрать общий `js` и `css` с этих страниц и положить их внутрь `pages/common/` как `common.js` и `common.css` соответственно.\n\n\n```javascript\n// Пробегаемся по всем директориям внутри \"pages\"\n// ...\nconfig.nodeMask(/pages\\/.*/, function (nodeConfig) {\n    // Если текущая нода common\n    if (nodeConfig.getPath() === 'pages/common') {\n        nodeConfig.addTechs([\n            [ require(\"enb/techs/levels\"), { levels: getLevels() } ],\n            require(\"enb/techs/files\"),\n\n            // Копируем депсы с каждоый страницы внутрь текущей ноды (pages/common)\n            [ require('enb/techs/deps-provider'), { sourceNodePath: 'pages/index', depsTarget: 'index.deps.js' } ],\n            [ require('enb/techs/deps-provider'), { sourceNodePath: 'pages/search', depsTarget: 'search.deps.js' } ],\n            [ require('enb/techs/deps-provider'), { sourceNodePath: 'pages/order', depsTarget: 'order.deps.js' } ],\n\n            // Склеиваем наши депсы в один (common.deps.js)\n            [ require('enb/techs/deps-merge'), { depsSources: ['index.deps.js', 'search.deps.js', 'order.deps.js'] } ],\n\n            require(\"enb/techs/js\"),\n            require(\"enb/techs/css\"),\n            [ require(\"enb/techs/css\"), {target: '?.ie9.css', sourceSuffixes: ['css', 'ie9.css'] } ]\n        ]);\n        // Собираем необходимые файлы\n        nodeConfig.addTargets([\"_?.js\", \"_?.css\", \"_?.ie9.css\"]);\n    } else {\n        nodeConfig.addTechs([\n            [ require(\"enb/techs/levels\"), { levels: getLevels() } ],\n            [ require(\"enb/techs/file-provider\"), { target: \"?.bemjson.js\" } ],\n            require(\"enb/techs/bemdecl-from-bemjson\"),\n            require(\"enb/techs/deps-old\"),\n            require(\"enb/techs/files\"),\n            require(\"enb-bemhtml/techs/bemhtml\"),\n            require(\"enb/techs/html-from-bemjson\"),\n            require(\"enb/techs/js\"),\n            [ require(\"enb/techs/i18n-merge-keysets\"), { lang: \"all\" }],\n            [ require(\"enb/techs/i18n-merge-keysets\"), { lang: \"{lang}\" }],\n            [ require(\"enb/techs/i18n-lang-js\"), { lang: \"all\" } ],\n            [ require(\"enb/techs/i18n-lang-js\"), { lang: \"{lang}\" } ],\n            [ require(\"enb/techs/js-i18n\"), { lang: \"{lang}\" } ],\n            require(\"enb/techs/css\"),\n            [ require(\"enb/techs/css\"), {target: '?.ie9.css', sourceSuffixes: ['css', 'ie9.css'] } ]\n        ]);\n        nodeConfig.addTargets([\"_?.js\", \"_?.css\", \"_?.ie9.css\", \"?.html\"]);\n    }\n\n    function getLevels() {\n        return [\n            {\"path\":\"bem-bl/blocks-common\",\"check\":false},\n            {\"path\":\"bem-bl/blocks-touch\",\"check\":false},\n            {\"path\":\"blocks\",\"check\":true}\n        ].map(function(l) { return config.resolvePath(l); });\n    }\n});\n// ...\n```\n\nОбратите внимание, директория `pages/common` должна сущестовать. Её можно создавать динамически.\n```javascript\n// ...\n  // Создание директории common\n  if (!fs.existsSync('pages/common')) {\n      fs.mkdirSync('pages/common');\n  }\n// ...\n```\n\nКонечно, если у вас много страниц и постоянно добавляются новые, то лучше обрабатывать это динамически:\n\nНеобходимо подключать модуль `fs`\n```javascript\nvar fs = require('fs');\n//...\nif (nodeConfig.getPath() === 'touch.bundles/common') {\n    var pagesDeps = [],\n        addTechsAttrs = [\n            [ require(\"enb/techs/levels\"), { levels: getLevels() } ],\n            require(\"enb/techs/files\"),\n            require(\"enb/techs/js\"),\n            require(\"enb/techs/css\"),\n            require(\"enb/techs/css-ie9\")\n        ];\n\n    // Проходимся по существующим страницам\n    fs.readdirSync('touch.bundles').map(function (page) {\n        if (page !== 'common') {\n            // Копируем депсы с каджой страницы внутрь common\n            addTechsAttrs.push([ require('enb/techs/deps-provider'), { sourceNodePath: 'touch.bundles/' + page, depsTarget: page + '.deps.js' } ]);\n\n            pagesDeps.push(page + '.deps.js');\n        }\n    });\n\n    // Мерджим все полученные депмы в один - common.deps.js\n    addTechsAttrs.push([ require('enb/techs/deps-merge'), { depsSources: pagesDeps } ]);\n\n    // прокидываем атрибуты\n    nodeConfig.addTechs(addTechsAttrs);\n    nodeConfig.addTargets([\"_?.js\", \"_?.css\", \"_?.ie9.css\"]);\n}\n//...\n```\n\nПодробное описание актуальных технологий\n========================================\n\nВ алфавитном порядке.\n\nВсе технологии, включенные в пакет `ENB`, находятся в папке `techs` пакета. Подключаются из make-файла с помощью `require('enb/techs/<tech-name>')`. Например, `require('enb/techs/js')`. Подключаются к ноде указанием класса и опций: `nodeConfig.addTech([ require('enb/techs/<tech-name>'), {/* [options] */} ]);`, либо без опций: `nodeConfig.addTech(require('enb/techs/<tech-name>'));`.\n\nЕсли при настройке технологии в опциях указана подстрока `{lang}`, то будет создано столько копий технологии, сколько языков установлено для ноды или проекта (если у ноды не указаны языки).\n\nНапример:\n\n```javascript\nnodeConfig.setLanguages(['ru', 'en', 'tk']);\nnodeConfig.addTech([require('js-i18n'), { target: '?.{lang}.js', lang: '{lang}' }]);\n```\n\nЭквивалентно:\n\n```javascript\nnodeConfig.addTech([require('js-i18n'), { target: '?.ru.js', lang: 'ru' }]);\nnodeConfig.addTech([require('js-i18n'), { target: '?.en.js', lang: 'en' }]);\nnodeConfig.addTech([require('js-i18n'), { target: '?.tk.js', lang: 'tk' }]);\n```\n\nbemdecl-from-bemjson\n--------------------\n\nФормирует *bemdecl* на основе `?.bemjson.js`.\n\n**Опции**\n\n* *String* **sourceTarget** — Исходный bemjson-таргет. По умолчанию — `?.bemjson.js`.\n* *String* **destTarget** — Результирующий bemdecl-таргет. По умолчанию — `?.bemdecl.js`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/bemdecl-from-bemjson'));\n```\n\nbemdecl-from-deps-by-tech\n-------------------------\n\nФормирует *bemdecl* на основе depsByTech-информации из `?.deps.js`.\n\n**Опции**\n\n* *String* **sourceTech** — Имя исходной технологии. Обязательная опция.\n* *String* **destTech** — Имя конечной технологии. Обязательная опция.\n* *String* **filesTarget** — files-таргет, на основе которого получается список исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `'deps.js'`.\n* *String* **target** — Результирующий bemdecl-таргет. По умолчанию — `?.bemdecl.js`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/bemdecl-from-deps-by-tech'), {\n    sourceTech: 'js',\n    destTech: 'bemhtml'\n});\n```\n\nbemdecl-merge\n-------------\n\nФормирует *bemdecl* с помощью объединения других bemdecl-файлов.\n\n**Опции**\n\n* *String[]* **bemdeclSources** — Исходные bemdecl-таргеты. Обязательная опция.\n* *String* **bemdeclTarget** — Результирующий bemdecl-таргет. По умолчанию — `?.bemdecl.js`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/bemdecl-merge'), {\n  bemdeclSources: ['search.bemdecl.js', 'router.bemdecl.js'],\n  bemdeclTarget: 'all.bemdecl.js'\n} ]);\n```\n\nbemdecl-provider\n----------------\n\nКопирует *bemdecl* в текущую ноду под нужным именем из другой ноды. Может понадобиться, например, для объединения bemdecl'ов.\n\n**Опции**\n\n* *String* **sourceNodePath** — Путь исходной ноды с нужным bemdecl'ом. Обязательная опция.\n* *String* **sourceTarget** — Исходный bemdecl, который будет копироваться. По умолчанию — `?.bemdecl.js` (демаскируется в рамках исходной ноды).\n* *String* **bemdeclTarget** — Результирующий bemdecl-таргет. По умолчанию — `?.bemdecl.js` (демаскируется в рамках текущей ноды).\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/bemdecl-provider'), {\n  sourceNodePath: 'bundles/router',\n  sourceTarget: 'router.bemdecl.js',\n  bemdeclTarget: 'router.bemdecl.js'\n}]);\n```\n\nborschik\n--------\n\nТехнология переехала в пакет `enb-borschik`.\n\nbrowser-js\n----------\n\nТехнология переехала в пакет `enb-diverse-js`.\n\ncss\n---\n\nСклеивает *css*-файлы по deps'ам, обрабатывает инклуды и ссылки, сохраняет в виде `?.css`.\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию `?.css`.\n* *String* **filesTarget** — files-таргет, на основе которого получается список исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `'css'`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/css'));\n```\n\ncss-borschik-chunks\n-------------------\n\nТехнология переехала в пакет `enb-borschik`.\n\n\ncss-chunks\n----------\n\nТехнология переехала в пакет `enb-bembundle`.\n\ncss-ie\n------\n\nТехнология устарела. Используйте технологию `css` с опцией `sourceSuffixes`.\n\ncss-ie6\n-------\n\nТехнология устарела. Используйте технологию `css` с опцией `sourceSuffixes`.\n\ncss-ie7\n-------\n\nТехнология устарела. Используйте технологию `css` с опцией `sourceSuffixes`.\n\ncss-ie8\n-------\n\nТехнология устарела. Используйте технологию `css` с опцией `sourceSuffixes`.\n\ncss-ie9\n-------\n\nТехнология устарела. Используйте технологию `css` с опцией `sourceSuffixes`.\n\ncss-ie-includes\n---------------\n\nТехнология устарела. Используйте технологию `css-includes` с опцией `sourceSuffixes`.\n\ncss-includes\n------------\n\nСобирает *css*-файлы по deps'ам инклудами, сохраняет в виде `?.css`. Может пригодиться в паре с ycssjs (как fastcgi-модуль).\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию `?.css`.\n* *String* **filesTarget** — files-таргет, на основе которого получается список исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `'css'`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/css-includes'));\n```\n\ncss-less\n--------\n\nТехнология устарела и будет удалена.\n\ncss-stylus\n----------\n\nСобирает *css*-файлы вместе со *styl*-файлами по deps'ам, обрабатывает инклуды и ссылки, сохраняет в виде `?.css`.\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию `?.css`.\n* *String* **filesTarget** — files-таргет, на основе которого получается список\n  исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `['css', 'styl']`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/css-stylus'));\n```\n\ncss-stylus-with-nib\n-------------------\n\nСобирает *css*-файлы вместе со *styl*-файлами по deps'ам, обрабатывает инклуды и ссылки, сохраняет в виде `?.css`.\nПри сборке *styl*-файлов использует [`nib`](https://github.com/visionmedia/nib).\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию `?.css`.\n* *String* **filesTarget** — files-таргет, на основе которого получается список\n  исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `['css', 'styl']`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/css-stylus-with-nib'));\n```\n\ndeps\n----\n\nБыстро собирает *deps.js*-файл на основе *levels* и *bemdecl*, раскрывая зависимости.\nСохраняет в виде `?.deps.js`.\nСледует использовать с осторожностью: в lego не хватает зависимостей,\nпотому проект может собраться иначе, чем с помощью bem-tools.\n\nИмя *levels*-таргета в данный момент не настраивается (нет запросов на эту функцию).\n\n**Опции**\n\n* *String* **bemdeclTarget** — Исходный bemdecl. По умолчанию — `?.bemdecl.js`.\n* *String* **levelsTarget** — Исходный levels. По умолчанию — `?.levels`.\n* *String* **depsTarget** — Результирующий deps. По умолчанию — `?.deps.js`.\n\n**Пример**\n\nОбычное использование:\n```javascript\nnodeConfig.addTech(require('enb/techs/deps'));\n```\n\nСборка специфического deps:\n```javascript\nnodeConfig.addTech([ require('enb/techs/deps'), {\n  bemdeclTarget: 'search.bemdecl.js',\n  depsTarget: 'search.deps.js'\n} ]);\n```\n\ndeps-merge\n-------------\n\nФормирует *deps* с помощью объединения других deps-файлов.\n\n**Опции**\n\n* *String[]* **depsSources** — Исходные deps-таргеты. Обязательная опция.\n* *String* **depsTarget** — Результирующий deps-таргет. По умолчанию — `?.deps.js`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/deps-merge'), {\n  depsSources: ['search.deps.js', 'router.deps.js'],\n  depsTarget: 'all.deps.js'\n} ]);\n```\n\ndeps-old\n--------\n\nСобирает *deps.js*-файл на основе *levels* и *bemdecl*, раскрывая зависимости.\nСохраняет в виде `?.deps.js`. Использует алгоритм, заимствованный из bem-tools.\n\nИмя *levels*-таргета в данный момент не настраивается (нет запросов на эту функцию).\n\n**Опции**\n\n* *String* **bemdeclTarget** — Исходный bemdecl. По умолчанию — `?.bemdecl.js`.\n* *String* **levelsTarget** — Исходный levels. По умолчанию — `?.levels`.\n* *String* **depsTarget** — Результирующий deps. По умолчанию — `?.deps.js`.\n\n**Пример**\n\nОбычное использование:\n```javascript\nnodeConfig.addTech(require('enb/techs/deps-old'));\n```\n\nСборка специфического deps:\n```javascript\nnodeConfig.addTech([ require('enb/techs/deps-old'), {\n  bemdeclTarget: 'search.bemdecl.js',\n  depsTarget: 'search.deps.js'\n} ]);\n```\n\ndeps-provider\n-------------\n\nКопирует *deps* в текущую ноду под нужным именем из другой ноды.\nМожет понадобиться, например, для объединения deps'ов.\n\n**Опции**\n\n* *String* **sourceNodePath** — Путь исходной ноды с нужным deps'ом. Обязательная опция.\n* *String* **sourceTarget** — Исходный deps, который будет копироваться. По умолчанию — `?.deps.js` (демаскируется в рамках исходной ноды).\n* *String* **depsTarget** — Результирующий deps-таргет. По умолчанию — `?.deps.js` (демаскируется в рамках текущей ноды).\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/deps-provider'), {\n  sourceNodePath: 'bundles/router',\n  sourceTarget: 'router.deps.js',\n  depsTarget: 'router.deps.js'\n} ]);\n```\n\ndeps-subtract\n-------------\n\nФормирует *deps* с помощью вычитания одного deps-файла из другого.\nМожет применяться в паре с `deps-provider` для получения deps для bembundle.\n\n**Опции**\n\n* *String* **subtractFromTarget** — Таргет, из которого вычитать. Обязательная опция.\n* *String* **subtractWhatTarget** — Таргет, который вычитать. Обязательная опция.\n* *String* **depsTarget** — Результирующий deps-таргет. По умолчанию — `?.deps.js`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTechs([\n  [ require('enb/techs/deps'), { depsTarget: 'router.tmp.deps.js' } ],\n  [ require('enb/techs/deps-provider'), { sourceNodePath: 'pages/index', depsTarget: 'index.deps.js' }],\n  [ require('enb/techs/deps-subtract'), {\n    subtractWhatTarget: 'index.deps.js',\n    subtractFromTarget: 'router.tmp.deps.js',\n    depsTarget: 'router.deps.js'\n  } ]\n]);\n```\n\nfile-copy\n---------\n\nКопирует один таргет в другой.\nМожет, например, использоваться для построения `_?.css` из `?.css` для development-режима.\n\n**Опции**\n\n* *String* **sourceTarget** — Исходный таргет. Обязательная опция.\n* *String* **destTarget** — Результирующий таргет. Обязательная опция.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/file-copy'), {\n  sourceTarget: '?.css',\n  destTarget: '_?.css'\n} ]);\n```\n\nfile-merge\n----------\n\nСклеивает набор файлов в один.\n\n**Опции**\n\n* *String[]* **sources** — Список исходных таргетов. Обязательная опция.\n* *String* **target** — Результирующий таргет. Обязательная опция.\n* *String* **divider** — Строка для склеивания файлов. По умолчанию — \"\\n\".\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/file-merge'), {\n    sources: ['?.bemhtml', '?.pre.js']\n    target: '?.js'\n} ]);\n```\n\nfile-provider\n-------------\n\nПредоставляет существующий файл для make-платформы.\nМожет, например, использоваться для предоставления исходного *bemdecl*-файла.\n\n**Опции**\n\n* *String* **target** — Таргет. Обязательная опция.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/file-provider'), { target: '?.bemdecl.js' } ]);\n```\n\nfiles\n-----\n\nСобирает список исходных файлов для сборки на основе *deps* и *levels*, предоставляет `?.files` и `?.dirs`.\nИспользуется многими технологиями, которые объединяют множество файлов из различных уровней переопределения в один.\n\n**Опции**\n\n* *String* **depsTarget** — Исходный deps-таргет. По умолчанию — `?.deps.js`.\n* *String* **levelsTarget** — Исходный levels. По умолчанию — `?.levels`.\n* *String* **filesTarget** — Результирующий files-таргет. По умолчанию — `?.files`.\n* *String* **dirsTarget** — Результирующий dirs-таргет. По умолчанию — `?.dirs`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/files'));\n```\n\nhtml-from-bemjson\n-----------------\n\nСобирает *html*-файл с помощью *bemjson* и *bemhtml*.\n\n**Опции**\n\n* *String* **bemhtmlTarget** — Исходный BEMHTML-файл. По умолчанию — `?.bemhtml.js`.\n* *String* **bemjsonTarget** — Исходный BEMJSON-файл. По умолчанию — `?.bemjson.js`.\n* *String* **destTarget** — Результирующий HTML-файл. По умолчанию — `?.html`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/html-from-bemjson'));\n```\n\nhtml-from-bemjson-i18n\n----------------------\n\nСобирает *html*-файл с помощью *bemjson*, *bemhtml*, *lang.all* и *lang.{lang}*.\n\n**Опции**\n\n* *String* **bemhtmlTarget** — Исходный BEMHTML-файл. По умолчанию — `?.bemhtml.js`.\n* *String* **bemjsonTarget** — Исходный BEMJSON-файл. По умолчанию — `?.bemjson.js`.\n* *String* **langAllTarget** — Исходный langAll-файл. По умолчанию — `?.lang.all.js`.\n* *String* **langTarget** — Исходный lang-файл. По умолчанию — `?.lang.{lang}.js`. Если параметр lang не указан, берется первый из объявленных в проекте языков\n* *String* **destTarget** — Результирующий HTML-файл. По умолчанию — `?.{lang}.html`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/html-from-bemjson-i18n'));\n```\n\ni18n-keysets-xml\n----------------\n\nСобирает `?.keysets.<язык>.xml`-файлы на основе `?.keysets.<язык>.js`-файлов.\n\nИспользуется для локализации xml-страниц, работающих в XScript (насколько я понимаю).\n\nИсходные и конечные таргеты в данный момент не настраиваются (нет запроса).\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию — `?.keysets.{lang}.js`.\n* *String* **lang** — Язык, для которого небходимо собрать файл.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('i18n-keysets-xml'), { lang: '{lang}' } ]);\n```\n\ni18n-lang-js\n------------\n\nСобирает `?.lang.<язык>.js`-файлы на основе `?.keysets.<язык>.js`-файлов.\n\nИспользуется для локализации в JS с помощью BEM.I18N.\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию — `?.lang.{lang}.js`.\n* *String* **lang** — Язык, для которого небходимо собрать файл.\n* *String* **keysetsTarget** — Исходный таргет. По умолчанию — `?.keysets.{lang}.js`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTechs([\n  [ require('i18n-lang-js'), { lang: 'all'} ],\n  [ require('i18n-lang-js'), { lang: '{lang}'} ],\n]);\n```\n\ni18n-lang-js-chunks\n-------------------\n\nСобирает `?.js-chunks.lang.<язык>.js`-файлы на основе `?.keysets.<язык>.js`-файлов.\n\nИспользуется для локализации в JS с помощью BEM.I18N при сборке bembundle.\n\nИсходные и конечные таргеты в данный момент не настраиваются (нет запроса).\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию — `?.js-chunks.lang.{lang}.js`.\n* *String* **lang** — Язык, для которого небходимо собрать файл.\n\n**Пример**\n\n```javascript\nnodeConfig.addTechs([\n  [ require('i18n-lang-js-chunks'), { lang: 'all' } ],\n  [ require('i18n-lang-js-chunks'), { lang: '{lang}' } ],\n]);\n```\n\ni18n-merge-keysets\n------------------\n\nСобирает `?.keysets.<язык>.js`-файлы на основе `*.i18n`-папок для указанных языков.\n\nИсходные и конечные таргеты в данный момент не настраиваются (нет запроса).\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию — `?.keysets.{lang}.js`.\n* *String* **lang** — Язык, для которого небходимо собрать файл.\n\n**Пример**\n\n```javascript\nnodeConfig.addTechs([\n  [ require('i18n-merge-keysets'), { lang: 'all' } ],\n  [ require('i18n-merge-keysets'), { lang: '{lang}' } ]\n]);\n```\n\njs\n--\n\nСклеивает *js*-файлы по deps'ам, сохраняет в виде `?.js`.\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию — `?.js`.\n* *String* **filesTarget** — files-таргет, на основе которого получается список исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `'js'`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/js'));\n```\n\njs-bundle-component\n-------------------\n\nТехнология переехала в пакет `enb-bembundle`.\n\njs-bembundle-component-i18n\n---------------------------\n\nТехнология переехала в пакет `enb-bembundle`.\n\njs-bundle-page\n--------------\n\nТехнология переехала в пакет `enb-bembundle`.\n\njs-bembundle-page-i18n\n----------------------\n\nТехнология переехала в пакет `enb-bembundle`.\n\njs-chunks\n---------\n\nТехнология переехала в пакет `enb-bembundle`.\n\njs-expand-includes\n------------------\n\nОбрабатывает инклуды в исходном `js`-файле и собирает результирующий файл. При раскрытии инклудов, если имя подключенного файла является таргетом, то ждет его выполнения.\n\n**Опции**\n\n* *String* **sourceTarget** — Исходный JS-таргет. Обязательная опция.\n* *String* **destTarget** — Результирующий JS-таргет. Обязательная опция.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/js-expand-includes'), { sourceTarget: '?.run-tests.js', destTarget: '_?.run-tests.js' } ]);\n```\n\njs-i18n\n-------\n\nСобирает `js`-файл по deps'ам и добавляет в результат таргет `?.lang.<язык>.js`. Используется с технологией `i18n-lang-js`.\n\n**Опции**\n\n* *String* **filesTarget** — files-таргет, на основе которого получается список исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `'js'`.\n* *String* **target** — Результирующий таргет. По умолчанию — `?.{lang}.js`.\n* *String* **lang** — Язык, для которого небходимо собрать файл.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/js-i18n'), { lang: '{lang}' } ]);\n```\n\njs-includes\n-----------\n\nСобирает *js*-файлы по deps'ам инклудами, сохраняет в виде `?.js`. Может пригодиться в паре с ycssjs (как fastcgi-модуль).\n\n**Опции**\n\n* *String* **filesTarget** — files-таргет, на основе которого получается список исходных файлов (его предоставляет технология `files`). По умолчанию — `?.files`.\n* *String* **sourceSuffixes** — суффиксы файлов, по которым строится `files`-таргет. По умолчанию — `'js'`.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech(require('enb/techs/js-includes'));\n```\n\nlevels\n------\n\nСобирает информацию об уровнях переопределения проекта, предоставляет `?.levels`. Результат выполнения этой технологии необходим технологиям `enb/techs/deps`, `enb/techs/deps-old` и `enb/techs/files`.\n\n**Опции**\n\n* *String* **target** — Результирующий таргет. По умолчанию — `?.levels`.\n* *(String|Object)[]* **levels** — Уровни переопределения. Полные пути к папкам с уровнями переопределения. Вместо строки с уровнем может использоваться объект вида `{path: '/home/user/www/proj/lego/blocks-desktop', check: false}` для того, чтобы закэшировать содержимое тех уровней переопределения, которые не модифицируются в рамках проекта.\n* *(String)[]* **sublevelDirectories** — Список директорий ноды с уровнями переопределения. По умолчанию — для каждой ноды добавляется уровень `<путь_к_ноде>/blocks`, например, для ноды `pages/index` — `pages/index/blocks`. Каждый следующий указаный уровень может переопределять предыдущий.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/levels'), {\n  levels: [\n    {path: 'lego/blocks-desktop', check: false},\n    'desktop.blocks'\n  ].map(function(level) { return config.resolvePath(level); })\n} ]);\n```\n\nnode-js\n-------\n\nТехнология переехала в пакет `enb-diverse-js`.\n\npriv-js\n-------\n\nТехнология переехала в пакет `enb-priv-js`.\n\npriv-js-i18n\n------------\n\nТехнология переехала в пакет `enb-priv-js`.\n\npriv-js-i18n-all\n----------------\n\nТехнология переехала в пакет `enb-priv-js`.\n\npub-js-i18n\n-----------\n\nТехнология переехала в пакет `enb-priv-js`.\n\nsymlink\n-------\n\nСоздает симлинк из одного таргета в другой. Может, например, использоваться для построения `_?.css` из `?.css` для development-режима.\n\n**Опции**\n\n* *String* **fileTarget** — Исходный таргет. Обязательная опция.\n* *String* **symlinkTarget** — Результирующий таргет. Обязательная опция.\n\n**Пример**\n\n```javascript\nnodeConfig.addTech([ require('enb/techs/symlink'), {\n  fileTarget: '?.css',\n  symlinkTarget: '_?.css'\n} ]);\n```\n\nvanilla-js\n----------\n\nТехнология переехала в пакет `enb-diverse-js`.\n\nxsl\n---\n\nТехнология переехала в пакет `enb-lego-xml`.\n\nxsl-2lego\n---------\n\nТехнология переехала в пакет `enb-lego-xml`.\n\nxsl-convert2xml\n---------------\n\nТехнология переехала в пакет `enb-lego-xml`.\n\nxsl-html5\n---------\n\nТехнология переехала в пакет `enb-lego-xml`.\n\nxsl-html5-i18n\n--------------\n\nТехнология переехала в пакет `enb-lego-xml`.\n\nxslt\n----\n\nТехнология переехала в пакет `enb-lego-xml`.\n\n## Как написать свою технологию\n\nС версии 0.8 технологии рекомендуется писать с использованием хэлпера `BuildFlow`.\n\nИсходный код хэлпера: https://github.com/enb-make/enb/blob/master/lib/build-flow.js\n\nВ данном руководстве охвачены не все возможности `BuildFlow`. Полный перечень методов с описанием находится\nв JSDoc файла `build-flow.js`.\n\n### Теория\n\nЦель технологии — собирать таргет в ноде. Например, технология `css` может собрать `index.css` в ноде `pages/index`\nна основе `css`-файлов по уровням переопределения.\n\nКаждая технология умеет принимать настройки.\nХэлпер `BuildFlow` способствует тому, чтобы максимальное количество параметров было настраиваемым.\n\nТехнологии могут использовать результат выполнения других технологий. Например, список исходных `css`-файлов\nстроится с помощью технологии `files`.\n\nВ общем случае, технологии создавать несложно. Бывают необычные ситуации.\nВ этом руководстве я постараюсь охватить и такие случаи.\n\n### Технология для склеивания файлов по суффиксу\n\nВ общем случае технология для склеивания файлов по нужному суффиксу выглядит следующим образом:\n\n```javascript\nmodule.exports = require('enb/lib/build-flow').create() // Создаем инстанцию BuildFlow\n    .name('js') // Выбираем имя для технологии\n    .target('target', '?.js') // Имя опции для задания имени результирующего файла и значение по умолчанию\n    .useFileList('js') // Указываем, какие суффиксы нас интересуют при сборке\n    .justJoinFilesWithComments() // Еще один хэлпер. Склеивает результат, обрамляя комментариями вида /* ... */\n                                 // в которых указывается путь к исходному файлу, из которого был сформирован фрагмент.\n    .createTech(); // Создаем технологию с помощью хэлпера\n```\n\nЭтот пример, конечно очень общий и слишком упрощенный.\n\nРассмотрим аналог этой технологии без использования `justJoinFilesWithComments`:\n\n```javascript\nvar Vow = require('vow'); // Используемая в ENB библиотека промисов\nvar vowFs = require('vow-fs'); // Работа с файловой системой на основе Vow\n\nmodule.exports = require('enb/lib/build-flow').create()\n    .name('js')\n    .target('target', '?.js')\n    .useFileList('js')\n    .builder(function(jsFiles) { // Будем возвращать промис, чтобы ENB ждал выполнения асинхронной технологии\n        var node = this.node; // Сохраняем ссылку на инстанцию класса `Node`.\n        return Vow.all(jsFiles.map(function(file) { // Ждем выполнения всех промисов\n            return vowFs.read(file.fullname, 'utf8').then(function(data) { // Читаем каждый исходный файл\n                var filename = node.relativePath(file.fullname); // Получаем путь относительно ноды\n                // Строим фрагменты из содержимого исходных файлов\n                return '/* begin: ' + filename + ' *' + '/\\n' + data + '\\n/* end: ' + filename + ' *' + '/';\n            });\n        })).then(function(contents) { // Получили результат обработки всех исходных файлов\n            return contents.join('\\n'); // Объединяем полученные фрагменты с помощью перевода строки\n        });\n    })\n    .createTech();\n```\n\nТак как мы использовали метод `useFileList`, в `builder` пришел аргумент со списком файлов по указанному суффиксу.\nКаждый `use`-метод добавляет аргумент в `builder`. Тип и содержимое аргументов зависят от того, какой `use`-метод был\nиспользован.\n\nДобавим к получившейся технологии файлы интернационализации:\n\n```javascript\nvar Vow = require('vow'); // Используемая в ENB библиотека промисов\nvar vowFs = require('vow-fs'); // Работа с файловой системой на основе Vow\n\nmodule.exports = require('enb/lib/build-flow').create()\n    .name('js')\n    .target('target', '?.js')\n    .defineRequiredOption('lang') // Определяем обязательную опцию lang для задания языка\n    .useFileList('js')\n\n    .useSourceText('allLangTarget', '?.lang.all.js') // Подключаем общую для всех языков интернационализацию,\n                                                     // используя метод useSourceText, который добавляет в\n                                                     // builder содержимое указанного файла в виде аргумента\n\n    .useSourceText('langTarget', '?.lang.{lang}.js') // Подключаем кейсеты конкретного языка;\n                                                     // здесь используется значение опции lang для того,\n                                                     // чтобы сформировать значение по умолчанию\n\n    .builder(function(jsFiles, allLangText, langText) {\n        var node = this.node;\n        return Vow.all(jsFiles.map(function(file) {\n            return vowFs.read(file.fullname, 'utf8').then(function(data) {\n                var filename = node.relativePath(file.fullname);\n                return '/* begin: ' + filename + ' *' + '/\\n' + data + '\\n/* end: ' + filename + ' *' + '/';\n            });\n        })).then(function(contents) {\n            return contents\n                .concat([allLangText, langText]) // Добавляем фрагменты содержимого файлов интернационализации\n                .join('\\n');\n        });\n    })\n    .createTech();\n```\n\n### Технология для склеивания нескольких целей\n\nРассмотрим готовый пример:\n\n```javascript\n// В данном примере строится локализованный priv.js\nmodule.exports = require('enb/lib/build-flow').create()\n    .name('priv-js-i18n')\n    .target('target', '?.{lang}.priv.js')\n    .defineRequiredOption('lang')\n\n    // Все эти цели подготавливаются другими технологиями:\n\n    .useSourceFilename('allLangTarget', '?.lang.all.js') // Устанавливаем зависимость от имени файла\n                                                         // общей интернационализации\n\n    .useSourceFilename('langTarget', '?.lang.{lang}.js') // Устанавливаем зависимость от имени файла\n                                                         // конкретного языка\n\n    .useSourceFilename('privJsTarget', '?.priv.js') // Устанавливаем зависимость от имени файла\n                                                    // priv-js файла\n\n    .justJoinFilesWithComments() // Пользуемся хэлпером для склеивания\n\n    .createTech();\n```\n\nРеализуем склеивание без хэлпера:\n\n```javascript\nmodule.exports = require('enb/lib/build-flow').create()\n    .name('priv-js-i18n')\n    .target('target', '?.{lang}.priv.js')\n    .defineRequiredOption('lang')\n    .useSourceFilename('allLangTarget', '?.lang.all.js')\n    .useSourceFilename('langTarget', '?.lang.{lang}.js')\n    .useSourceFilename('privJsTarget', '?.priv.js')\n\n    .builder(function(allLangFilename, langFilename, privJsFilename) {\n        var node = this.node;\n        // Перебираем исходные файлы\n        return Vow.all([allLangFilename, langFilename, privJsFilename].map(function(absoluteFilename) {\n            // Читаем каждый исходный файл\n            return vowFs.read(absoluteFilename, 'utf8').then(function(data) {\n                // Получаем относительный путь к файлу\n                var filename = node.relativePath(absoluteFilename);\n\n                // Формируем фрагмент\n                return '/* begin: ' + filename + ' *' + '/\\n' + data + '\\n/* end: ' + filename + ' *' + '/';\n            });\n        })).then(function(contents) {\n            return contents.join('\\n'); // Склеиваем фрагменты\n        });\n    })\n\n    .createTech();\n```\n\n### Зависимости от файлов, не входящих в сборку\n\nНапример, нам надо добавить модульную систему в начало какого-нибудь файла и сохранить результат под новым именем:\n\n```javascript\nvar vowFs = require('vow-fs'); // Подключаем модуль для работы с файловой системой\nvar path = require('path'); // Подключаем утилиты работу с путями\n\nmodule.exports = require('enb/lib/build-flow').create()\n    .name('prepend-modules')\n    .target('target', '?.js')\n    .defineRequiredOption('source') // Указываем обязательную опцию\n    .useSourceText('source', '?') // Устанавливаем зависимость от содержимого цели, задаваемой опцией source\n    .needRebuild(function(cache) { // Указываем дополнительную проверку кэша\n        // В данном случае модульная система не находится в исходных уровнях переопределения,\n        // но ее можно найти в пакете ym; для того, чтобы пересборка правильно работало в случае\n        // изменения содержимого файла modules.js, добавляем проверку\n        this._modulesFile = path.join(__dirname, '..', 'node_modules', 'ym', 'modules.js'); // Формируем путь\n        return cache.needRebuildFile( // Проверяем, изменился ли файл\n            'modules-file', // Ключ для кэширования данных о файле; должен быть уникален в рамках технологии\n            this._modulesFile // Путь к файлу, для которого необходимо проверить кэш\n        );\n    })\n    .saveCache(function(cache) { // Сохраняем в кэш данные об использованном файле\n        cache.cacheFileInfo( // Сохраняем в кэш информацию о файле\n            'modules-file', // Ключ для кэширования данных о файле; должен быть уникален в рамках технологии\n            this._modulesFile // Путь к файлу, для которого необходимо проверить кэш\n        );\n    })\n    .builder(function(preTargetSource) {\n        // Считываем содержимое файла модульной системы\n        return vowFs.read(this._modulesFile, 'utf8').then(function(modulesRes) {\n            return modulesRes + preTargetSource; // Объединяем результаты\n        });\n    })\n    .createTech();\n```\n\n### То же самое, но чуть-чуть иначе\n\nВремя от времени возникают ситуации, когда надо немного дополнить существующие технологии.\n\nНапример, нам нравится, как работает технология `css`:\n\n```javascript\nmodule.exports = require('enb/lib/build-flow').create()\n    .name('css')\n    .target('target', '?.css')\n    .useFileList('css')\n    .builder(function(cssFiles) {\n        // ...\n    })\n    .methods({\n        // ...\n    })\n    .createTech();\n```\n\nВ каждой технологии, сделанной с помощью `BuildFlow`, есть метод `buildFlow()`, который можно вызвать для того,\nчтобы создать новую технологию на основе функционала существующей.\n\nВ какой-то момент нам понадобилось вместе с суффиксами `css` собирать еще и `light.css`.\nДля этого надо написать новую технологию, заимствуя функционал старой:\n\n```javascript\nmodule.exports = require('enb/techs/css').buildFlow()\n    .name('css-light') // Изменяем имя\n    .useFileList(['css', 'light.css']) // Изменяем нужные параметры\n    .createTech();\n```\n\n## Node API\n\nКаждой технологии в `init` приходит инстанция ноды, для которой необходимо собирать таргеты.\nЧерез ноду технология взаимодействует с процессом сборки.\n\nОсновные методы класса Node:\n\nnode.getTargetName\n------------------\n\n```javascript\n// Возвращает имя таргета ноды без суффикса. Например, для ноды 'pages/index' результат — index.\nString Node::getTargetName()\n// Возвращает имя таргета ноды с суффиксом. Например, для ноды 'pages/index' с суффиксом 'js' результат — 'index.js'.\nString Node::getTargetName(String suffix)\n```\n\nnode.unmaskTargetName\n---------------------\n\n```javascript\n// Демаскирует имя таргета ноды. Например, для ноды 'pages/index' и maskedTargetName='?.css', результат — 'index.css'.\nString Node::unmaskTargetName(String maskedTargetName)\n```\n\nnode.resolvePath\n----------------\n\n```javascript\n// Возвращает абсолютный путь к таргету.\nString Node::resolvePath(String targetName)\n```\n\n**Пример**\n\n```javascript\nvar fs = require('fs');\nfs.writeFileSync(this.node.resolvePath(this.node.getTargetName('js')), 'alert(\"Hello World!\");', 'utf8');\n```\n\nnode.resolveTarget\n------------------\n\n```javascript\n// Оповещает ноду о том, что таргет собран. Опционально принимает результат сборки.\n// Результатом может быть любой объект, который может быть полезен другим технологиям для продолжения сборки.\nundefined Node::resolveTarget(String targetName[, Object result])\n```\n\n**Примеры**\n\n```javascript\n// #1\nthis.node.resolveTarget('index.css');\n\n// #2 Получаем имя таргета динамически с помощью суффикса.\nthis.node.resolveTarget(this.node.getTargetName('css'));\n\n// #3 Получаем имя таргета путем демаскирования таргета.\nthis.node.resolveTarget(this.node.unmaskTargetName('?.css'));\n\n// #4 Передаем значение.\nvar target = this.node.unmaskTargetName('?.deps.js'),\n    targetPath = this.node.resolvePath(target);\ndelete require.cache[targetPath]; // Избавляемся от кэширования в nodejs.\nthis.node.resolveTarget(target, require(targetPath));\n```\n\nnode.rejectTarget\n------------------\n\n```javascript\n// Оповещает ноду о том, что таргет не может быть собран из-за ошибки.\nundefined Node::rejectTarget(String targetName, Error error)\n```\n\n**Примеры**\n\n```javascript\n// #1\nthis.node.rejectTarget('index.css', new Error('Could not find CSS Tools.'));\n\n// #2 Получаем имя таргета динамически с помощью суффикса.\nthis.node.rejectTarget(this.node.getTargetName('css'), new Error('Could not find CSS Tools.'));\n```\n\nnode.requireSources\n-------------------\n\n```javascript\n// Требует у ноды таргеты для дальнейшей сборки, возвращает промис.\n// Промис выполняется, возвращая массив результатов, которыми резолвились требуемые таргеты.\n// ВАЖНО: Не все технологии резолвят таргеты с результатом.\n// В данный момент резолвят с результатом технологии: levels, deps*, files.\nPromise(Object[]) Node::requireSources(String[] targetNames)\n```\n\n**Пример**\n\nНапример, нам надо объединить в один файл `index.css` и `index.ie.css` и записать в `index.all.css`.\n\n```javascript\nvar vowFs = require('vow-fs');\n// ...\n  build: function() {\n    var _this = this;\n    return this.node.requireSources(['index.css', 'index.ie.css']).then(function() {\n      return Vow.all([vowFs.read(_this.node.resolvePath('index.css'), 'utf8'), vowFs.read(_this.node.resolvePath('index.ie.css'), 'utf8')]).then(function(res) {\n        return vowFs.write(_this.node.resolvePath('index.all.css'), res.join('\\n'), 'utf8').then(function() {\n          _this.node.resolveTarget('index.all.css');\n        });\n      });\n    });\n  }\n// ...\n```\n\nПример использования: [Технология deps](/mdevils/enb/blob/master/techs/deps.js#L31)\n\nnode.relativePath\n-----------------\n\n```javascript\n// Возвращает относительный путь к таргету относительно ноды.\nString Node::relativePath(String targetName)\n```\n\nПример использования: [Технология css-includes](/mdevils/enb/blob/master/techs/css-includes.js#L16)\n\nnode.getDir\n-----------\n\n```javascript\n// Возвращает полный путь к папке ноды.\nString Node::getDir()\n```\n\nnode.getRootDir\n---------------\n\n```javascript\n// Возвращает полный путь к корневой папке проекта.\nString Node::getRootDir()\n```\n\nnode.getLogger\n--------------\n\n[Logger](/mdevils/enb/blob/master/lib/logger.js)\n\n```javascript\n// Возвращает инстанцию логгера для ноды.\nLogger Node::getLogger()\n```\n\n**Пример**\n\n```javascript\nthis.node.getLogger().log('Hello World');\n```\n\nПример использования: [Технология deps](/mdevils/enb/blob/master/techs/deps.js#L79)\n\nnode.getNodeCache\n-----------------\n\n[Cache](/mdevils/enb/blob/master/lib/cache/cache.js)\n\n```javascript\n// Возвращает инстанцию кэша для таргета ноды.\nCache Node::getNodeCache(String targetName)\n```\n\nКэширование необходимо для того, чтобы избегать повторной сборки файлов, для которых сборка не требуется. Кэшируется время изменения исходных и конечных файлов после окончания сборки каждой технологии. Логика кэширования реализуется в каждой технологии индивидуально для максимальной гибкости.\n\nС помощью методов `Boolean needRebuildFile(String cacheKey, String filePath)` и `Boolean needRebuildFileList(String cacheKey, FileInfo[] files)` производится валидация кэша.\n\nС помощью методов `undefined cacheFileInfo(String cacheKey, String filePath)` и `undefined cacheFileList(String cacheKey, FileInfo[] files)` производится сохранение информации о файлах в кэш.\n\nПример использования:\n\n* Валидация кэша: [Технология deps](/mdevils/enb/blob/master/techs/deps.js#L33)\n* Кэширование результатов сборки: [Технология deps](/mdevils/enb/blob/master/techs/deps.js#L73)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/enb-make/enb/issues"
  },
  "_id": "enb@0.13.17",
  "_from": "enb@^0.13.15"
}
