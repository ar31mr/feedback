{
  "name": "xjst",
  "description": "XSLT inspired JavaScript templates (with spices)",
  "version": "1.5.3",
  "homepage": "http://github.com/veged/xjst",
  "author": {
    "name": "Sergey Berezhnoy",
    "email": "veged@mail.ru",
    "url": "http://github.com/veged"
  },
  "contributors": [
    {
      "name": "Fedor Indutny",
      "email": "fedor.indutny@gmail.com",
      "url": "https://github.com/indutny"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/veged/xjst.git"
  },
  "main": "./lib/xjst",
  "directories": {
    "lib": "./lib"
  },
  "bin": {
    "xjst": "./bin/xjst"
  },
  "dependencies": {
    "coa": "~ 0.4.0",
    "q": "~ 0.9.7",
    "esprima": "~1.1.1",
    "uglify-js": "~2.4.0",
    "estraverse": "~1.5.0"
  },
  "devDependencies": {
    "mocha": "~1.12.1",
    "benchmark": "~1.0.0",
    "watch": "~0.7.0"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "licenses": [
    {
      "type": "AS IS"
    }
  ],
  "scripts": {
    "test": "mocha --slow 600 --growl --reporter spec test/unit/*-test.js"
  },
  "readme": "     ___ ___    _____  _______  _______\n    |   |   | _|     ||     __||_     _|\n    |-     -||       ||__     |  |   |\n    |___|___||_______||_______|  |___|\n\n## Extensible JavaScript Transformations [![Build Status](https://secure.travis-ci.org/veged/xjst.png)](http://travis-ci.org/veged/xjst)\n\nXJST is a DSL for universal data transformations with compiler written on top of\nthe [Node.js][1] and [Ometa/JS][2] and output code working in any browser or on\nserver-side.\n\n## Data transformations?\n\nYes, traverse any data in specific flow using matching against conditions set\nto generate any output (see [binary tree prefixer][6]).\n\nFor example, XJST can be used as:\n\n* HTTP request router\n* template engine\n* AST transformator\n* parser\n\n## Extensible\n\nXJST makes possible to extend your previous transformation by overriding or\nspecializing some of it's parts (example below is extending\n`this.url === '/login'` condition with redirection for logged in users).\n\nXJST is a superset of JavaScript so you can use any popular libraries (that is\njquery or underscore) within your transformation and write condition bodies in\nJavaScript.\n\nCreating your own DSL based on XJST is also possible, because it's syntax parser\nis powered by [ometajs][2].\n\n## Basic example\n\nInput:\n\n```javascript\ntemplate(this.url === '/')(function() {\n  return render('home page')\n});\n\ntemplate(this.url === '/login')(function() {\n  return render('login form')\n});\n\ntemplate(this.url === '/login', this.cookie.is_logined)(function() {\n  return redirect('user page')\n});\n```\n\nOutput (simplified):\n\n```javascript\nswitch (this.url) {\n  case '/login':\n    switch (this.cookie.is_logined) {\n      case true:\n        return redirect('user page')\n      default:\n        return render('login form')\n    }\n  case '/':\n    return render('home page')\n}\n```\n\n[More examples][5]\n\n## Installation\n\n```bash\nnpm install xjst\n```\n\n## Public API\n\n```javascript\nvar xjst = require('xjst'),\n\n    fn = xjst.compile('template string', 'filename.xjst', options);\n\nfn({ your: 'data' });\n```\n\n## Syntax\n\nXJST extends JavaScript syntax with a following keywords: `template`, `local`,\n`apply`, `applyNext`.\n\n### Template\n\n```javascript\ntemplate(expression1 === value1, ... , expressionN === valueN)(function() {\n  // will be run if condition above equals to true\n})\n```\n\nMultiple `template` statements will be grouped to construct optimal conditions\ngraph. Order of the `template` statements matters, the priority decreases from\nthe bottom to the top.\n\nThere're few restrictions for templates:\n\n*   Expressions in template predicate should have no side-effects\n    (that is should not change transformation context).\n\n*   It's preferred to use function calls or equality comparisons joined by\n    logical `&&` operator for expressions, as it can be better optimized at\n    compilation time.\n\n### Local\n\n```javascript\nvar obj = { x: 1 };\n\nconsole.log(local(obj)({ x: 2 })(obj.x)); // 2\nconsole.log(obj.x); // 1\n```\n\n`local` allows you to make temporary changes to a visible variables scope. Every\nassignment put inside parens will be reverted immediately after the expression\nexecution.\n\nYou can make multiple assignments in the one statement:\n\n```javascript\nlocal({ x: 2, y: 3 })(/* your code */)\n```\n\nOr use `local` with a block:\n\n```javascript\nlocal({ ... })(function() { var a = 1; return a * 2; });\n```\n\nOr as an expression:\n\n```javascript\nvar newX = local(this)({ x: 2 })(this.x);\n```\n\n### Apply\n\n```javascript\ntemplate(true)(function() {\n  return apply({ type: 'first' });\n});\n\ntemplate(this.type === 'first')(function() {\n  return apply({ type: 'second' });\n});\n\ntemplate(this.type === 'second')(function() {\n  return 'here am I';\n});\n```\n\nXJST is intended to be applied recursively to the same data, while making small\ntemporary changes to it (all changes will be reverted back after operation).\n`apply` keyword works exactly like a `local` (applying changes in the parens and\nreverting them after the execution), but with small distinction - `apply`\ndoesn't have a body, so it's just doing some changes to the data and applying\ntemplate recursively (the context will be preserved).\n\n### Apply next\n\n```javascript\ntemplate(this.page === 'home' && this.action === 'login')(function() {\n  // match here\n});\n\ntemplate(this.page === 'home')(function() {\n  applyNext();\n});\n```\n\n`applyNext()` call will reapply all templates, except one where it was called,\nto the inputs data.\n\n## CLI interface\n\n```bash\n$ bin/xjst --help\n\nUsage:\n  xjst [OPTIONS] [ARGS]\n\n\nOptions:\n  -h, --help : Help\n  -i INPUT, --input=INPUT : Input file (default: stdin)\n  -o OUTPUT, --output=OUTPUT : Output file (default: stdout)\n\n$ bin/xjst -i template.xjst\n\n.... some code ...\n```\n\n## Optimizations\n\n![Optimized graph][7]\n\nXJST takes all the `template` statements and produces a tree with comparisons in\nnodes and `template` bodies in leafs. `apply` are handled and replaced by\ndirect calls to the tree nodes (some of comparisons can be skipped, using\nknown context state).\n\nInput:\n\n```javascript\ntemplate(this.type === 'a')(function() {\n  // body 1\n});\ntemplate(this.type === 'b')(function() {\n  // body 2\n});\n```\n\nOutput (simplified):\n\n```javascript\nswitch (this.type) {\n  case 'a':\n    // body 1\n    break;\n  case 'b':\n    // body 2\n    break;\n}\n```\n\n## Documentation\n\nHere is the [documented source][3].\n\nSome technical details (in Russian) can be found in [doc/tech.ru.md][4].\n\n#### Contributors\n\n* [Sergey Berezhnoy](https://github.com/veged)\n* [Andrey Mischenko](https://github.com/druxa)\n* [Fedor Indutny](https://github.com/indutny)\n\n[1]: http://nodejs.org/\n[2]: https://github.com/veged/ometa-js\n[3]: http://veged.github.com/xjst/\n[4]: https://github.com/veged/xjst/blob/master/doc/tech.ru.md\n[5]: https://github.com/veged/xjst/tree/master/examples\n[6]: https://github.com/veged/xjst/blob/master/examples/prefixer/source.xjst\n[7]: https://github.com/veged/xjst/raw/master/graph.jpg \"Optimized graph\"\n\n\n<!-- Yandex.Metrika counter -->\n<img src=\"//mc.yandex.ru/watch/12831025\" style=\"position:absolute; left:-9999px;\" alt=\"\" />\n<!-- /Yandex.Metrika counter -->\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/veged/xjst/issues"
  },
  "_id": "xjst@1.5.3",
  "_from": "xjst@1.5.3"
}
